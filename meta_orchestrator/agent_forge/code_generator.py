import os
from typing import Dict, Any

class CodeGenerator:
    """Generates agent source code from a design specification.

    This class takes a design blueprint from the AgentDesigner and uses a
    template-based approach to generate the full Python source code for the
    new agent variant.
    """

    def __init__(self) -> None:
        """Initializes the CodeGenerator with a mapping of architectures to templates."""
        self.templates = {
            "Monolithic": self._get_monolithic_template,
            "Modular": self._get_modular_template,
            # Add other architecture templates here
        }

    def generate_and_write_code(self, design_spec: Dict[str, Any], output_dir: str) -> str:
        """Generates the agent's source code and writes it to a file.

        Selects the appropriate code template based on the agent's specified
        architecture, populates it with the design details, and saves it
        to a new Python file.

        Args:
            design_spec: The agent design blueprint from the AgentDesigner.
            output_dir: The base directory to write the new variant file to.

        Returns:
            The full path to the newly created source file.
        """
        architecture = design_spec.get("architecture", "Monolithic")
        template_func = self.templates.get(architecture, self.templates["Monolithic"])

        source_code = template_func(design_spec)

        filepath = os.path.join(output_dir, design_spec["source_file"])

        print(f"  - Generating source code for '{design_spec['name']}'...")
        with open(filepath, "w") as f:
            f.write(source_code)

        print(f"  - Successfully wrote source code to: {filepath}")
        return filepath

    def _get_monolithic_template(self, spec: Dict[str, Any]) -> str:
        """Returns the code template for a simple, monolithic agent.

        Args:
            spec: The agent design specification.

        Returns:
            A string containing the Python code for the agent.
        """
        return f"""\
# Auto-generated by the Agent Forge
import time
from typing import Dict, Any

from ....core.base_variant import AgentVariant
from ...registry import register

class {spec['name']}(AgentVariant):
    \"\"\"
    {spec['description']}
    This is a monolithic agent, with all logic contained in the run method.
    \"\"\"

    def __init__(self, params: Dict[str, Any] = None):
        super().__init__(params)
        # Attribute: {spec.get('attributes')}
        print("Initializing {spec['name']} with attributes: {spec.get('attributes')}")

    def run(self, context: Dict[str, Any]) -> Dict[str, Any]:
        print(f"  - {spec['name']}: Executing task...")
        time.sleep(0.05) # Simulate work

        # TODO: Implement agent logic based on its design
        # For example, a 'Stateful' agent would use a cache here.

        return {{
            "success": 1,
            "cost": 0.003, # Placeholder cost
            "autonomy": 0.5, # Placeholder autonomy
            "design_spec": {{
                "architecture": "{spec['architecture']}",
                "attributes": {spec['attributes']}
            }}
        }}

# Register a default instance of the new agent
register("{spec['name'].lower()}")({spec['name']}())
"""

    def _get_modular_template(self, spec: Dict[str, Any]) -> str:
        """Returns the code template for a more complex, modular agent.

        Args:
            spec: The agent design specification.

        Returns:
            A string containing the Python code for the agent.
        """
        return f"""\
# Auto-generated by the Agent Forge
import time
from typing import Dict, Any

from ....core.base_variant import AgentVariant
from ...registry import register

class {spec['name']}(AgentVariant):
    \"\"\"
    {spec['description']}
    This is a modular agent, with logic separated into different components.
    \"\"\"

    def __init__(self, params: Dict[str, Any] = None):
        super().__init__(params)
        self.attributes = {spec.get('attributes')}
        print("Initializing {spec['name']} with attributes: {{self.attributes}}")
        self._setup_modules()

    def _setup_modules(self):
        \"\"\"Initializes the agent's internal components.\"\"\"
        # TODO: Implement module setup based on attributes
        # e.g., if self.attributes.get("Memory") == "Long-Term":
        #          self.memory_module = LongTermMemoryModule()
        print("  - Setting up internal modules...")
        self.planner = self._Planner(self.attributes)
        self.executor = self._Executor(self.attributes)

    def run(self, context: Dict[str, Any]) -> Dict[str, Any]:
        print(f"  - {spec['name']}: Orchestrating modules...")

        # 1. Planner runs first
        plan = self.planner.generate_plan(context)

        # 2. Executor runs second
        execution_result = self.executor.execute_plan(plan)

        return {{
            "success": 1 if execution_result else 0,
            "cost": 0.007, # Higher placeholder cost for modular complexity
            "autonomy": 0.7, # Higher placeholder autonomy
            "design_spec": {{
                "architecture": "{spec['architecture']}",
                "attributes": {spec['attributes']}
            }}
        }}

    class _Planner:
        def __init__(self, parent_attributes):
            self.attributes = parent_attributes
        def generate_plan(self, context):
            print("    - Planner Module: Generating plan...")
            time.sleep(0.03)
            return ["step1", "step2"]

    class _Executor:
        def __init__(self, parent_attributes):
            self.attributes = parent_attributes
        def execute_plan(self, plan):
            print(f"    - Executor Module: Executing {{len(plan)}}-step plan...")
            time.sleep(0.04)
            return True

# Register a default instance of the new agent
register("{spec['name'].lower()}")({spec['name']}())
"""

# Example Usage
if __name__ == '__main__':
    from designer import AgentDesigner

    designer = AgentDesigner()
    spec = designer.design_new_variant()

    generator = CodeGenerator()

    # Define a temporary output directory for the example
    temp_dir = "temp_generated_variants"
    os.makedirs(temp_dir, exist_ok=True)

    generated_file = generator.generate_and_write_code(spec, temp_dir)

    print("\n--- Generated Source Code ---")
    with open(generated_file, "r") as f:
        print(f.read())

    # Clean up the temporary file and directory
    import shutil
    shutil.rmtree(temp_dir)